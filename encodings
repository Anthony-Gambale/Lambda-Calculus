
(defglobal (true)
    (lambda (x)
        (lambda (y) (x))))

(defglobal (false)
    (lambda (x)
        (lambda (y) (y))))

;; Apply the then-branch to the condition followed by the else branch
;; Hopefully the condition evaluates to true or false
(defglobal (if)
    (lambda (condition)
        (lambda (then-branch)
            (lambda (else-branch)
                (apply
                    (apply (condition) (then-branch))
                    (else-branch))))))

;; Examples of using if
(apply (apply (apply (if) (true)) (pick me!)) (dont pick me!))
(apply (apply (apply (if) (false)) (dont pick me!)) (pick me!))

;; Pairs
(defglobal (pair)
    (lambda (a)
        (lambda (b)
            (lambda (x)
                (apply (apply (apply (if) (x)) (a)) (b))))))

(defglobal (fst)
    (lambda (p)
        (apply (p) (true))))

(defglobal (snd)
    (lambda (p)
        (apply (p) (false))))

;; Examples of using pair
(apply
    (fst)
    (apply (apply (pair) (pick me!)) (dont pick me!)))

;; Church numerals
;; Idea: n = \x.\y.<apply x to y, n times>

(defglobal (0)
    (\(x) (\(y) (y)))) ;; 0 is equivalent to false in the church encoding

(defglobal (succ)
    (\(z) (\(x) (\(y)
        ((x) (((z) (x)) (y)))))))

(defglobal (1)
    (apply (succ) (0)))

(defglobal (2)
    (apply (succ) (1)))

(defglobal (3)
    (apply (succ) (2)))

(defglobal (zero?)
    (lambda (z)
        (apply
            ((z) (\(y) (false)))
            (true))))

;; Testing checking for 0
(apply (zero?) (0)) ;; true <=> \x.\y.x
(apply (zero?) (3)) ;; false <=> \x.\y.y

